package demo.spk

import org.apache.spark.SparkConf
import org.apache.spark.storage.StorageLevel
import org.apache.spark.streaming.{Seconds, StreamingContext}


/**
 * 套接字流
 * nc -lk 9999
 *
 * @author admin 2020-5-26
 */
object StreamSocket extends App {
  val hostname = "localhost"
  val port = "9999"

  StreamingExamples.setStreamingLogLevels()
  // Create the context with a 1 second batch size
  val conf = new SparkConf().setMaster("local[2]").setAppName("StreamSocket")
  val ssc = new StreamingContext(conf, Seconds(1))

  /*  Create a socket stream on target ip:port and count the
  words in input stream of \n delimited text (eg. generated by 'nc')
  Note that no duplication in storage level only for running locally.
  Replication necessary in distributed scenario for fault tolerance.*/
  val lines = ssc.socketTextStream(hostname, port.toInt, StorageLevel.MEMORY_AND_DISK_SER)
  val words = lines.flatMap(_.split(" "))
  val wordCounts = words.map(x => (x, 1)).reduceByKey(_ + _)
  wordCounts.print()
  ssc.start()
  ssc.awaitTermination()
}

import org.apache.log4j.{Level, Logger}
import org.apache.spark.internal.Logging

object StreamingExamples extends Logging {
  /** Set reasonable logging levels for streaming if the user has not configured log4j. */
  def setStreamingLogLevels() {
    val log4jInitialized = Logger.getRootLogger.getAllAppenders.hasMoreElements
    if (!log4jInitialized) {
      // We first log something to initialize Spark's default logging, then we override the logging level.
      logInfo(".... Setting log level to [WARN] for streaming example." +
        " To override add a custom log4j.properties to the classpath.")
      Logger.getRootLogger.setLevel(Level.WARN)
    }
  }
}

import java.io.PrintWriter
import java.net.ServerSocket

import scala.io.Source

/**
 * 生成socket信息 by local file
 */
case object GenerateSocket {
  def generateByFile(fileName: String): Unit = {
    val lines = Source.fromFile(fileName).getLines.toList
    val listener = new ServerSocket(StreamSocket.port.toInt)
    while (true) {
      val socket = listener.accept()
      new Thread() {
        override def run = {
          println("Got client connected from: " + socket.getInetAddress)
          val out = new PrintWriter(socket.getOutputStream(), true)
          while (true) {
            Thread.sleep("1000".toLong)
            val content = lines(index(lines.length))
            println(content)
            out.write(content + '\n')
            out.flush()
          }
          socket.close()
        }
      }.start()
    }
  }

  def index(length: Int) = {
    val rdm = new java.util.Random
    rdm.nextInt(length)
  }
}